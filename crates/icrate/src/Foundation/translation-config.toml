imports = ["Foundation"]

[class.NSObject.methods]
# Uses NS_REPLACES_RECEIVER
awakeAfterUsingCoder = { skipped = true }

[protocol.NSKeyedUnarchiverDelegate.methods]
# Uses NS_RELEASES_ARGUMENT and NS_RETURNS_RETAINED
unarchiver_didDecodeObject = { skipped = true }

[class.NSBlockOperation.methods]
# Uses `NSArray<void (^)(void)>`, which is difficult to handle
executionBlocks = { skipped = true }

# These use `Class<NSItemProvider...>`, which is unsupported
[class.NSItemProvider.methods]
registerObjectOfClass_visibility_loadHandler = { skipped = true }
canLoadObjectOfClass = { skipped = true }
loadObjectOfClass_completionHandler = { skipped = true }

# These use `SomeObject * __strong *`, which is unsupported
[class.NSNetService.methods]
getInputStream_outputStream = { skipped = true }
[class.NSPropertyListSerialization.methods]
dataFromPropertyList_format_errorDescription = { skipped = true }
propertyListFromData_mutabilityOption_format_errorDescription = { skipped = true }

# Has `error:` parameter, but returns NSInteger (where 0 means error)
[class.NSJSONSerialization.methods.writeJSONObject_toStream_options_error]
skipped = true
[class.NSPropertyListSerialization.methods.writePropertyList_toStream_format_options_error]
skipped = true

# Not supported on clang 11.0.0
[class.NSBundle.methods.localizedAttributedStringForKey_value_table]
skipped = true

# Both instance and class methods
[class.NSUnarchiver.methods.decodeClassName_asClassName]
skipped = true
[class.NSUnarchiver.methods.classNameDecodedForArchiveClassName]
skipped = true
[class.NSAutoreleasePool.methods.addObject]
skipped = true
[class.NSBundle.methods.pathForResource_ofType_inDirectory]
skipped = true
[class.NSBundle.methods.pathsForResourcesOfType_inDirectory]
skipped = true
[class.NSKeyedArchiver.methods.setClassName_forClass]
skipped = true
[class.NSKeyedArchiver.methods.classNameForClass]
skipped = true
[class.NSKeyedUnarchiver.methods.setClass_forClassName]
skipped = true
[class.NSKeyedUnarchiver.methods.classForClassName]
skipped = true
[class.NSThread.methods.threadPriority]
skipped = true
[class.NSThread.methods.setThreadPriority]
skipped = true
[class.NSThread.methods.isMainThread]
skipped = true
[class.NSDate.methods.timeIntervalSinceReferenceDate]
skipped = true

# Root class
[class.NSProxy]
definition-skipped = true
[class.NSProxy.methods]
alloc = { skipped = true }
allocWithZone = { skipped = true }

# Contains bitfields
[struct.NSDecimal]
skipped = true

# Uses stuff from core Darwin libraries which we have not yet mapped
[class.NSAppleEventDescriptor.methods]
descriptorWithDescriptorType_bytes_length = { skipped = true }
descriptorWithDescriptorType_data = { skipped = true }
appleEventWithEventClass_eventID_targetDescriptor_returnID_transactionID = { skipped = true }
descriptorWithProcessIdentifier = { skipped = true }
initWithAEDescNoCopy = { skipped = true }
initWithDescriptorType_bytes_length = { skipped = true }
initWithDescriptorType_data = { skipped = true }
initWithEventClass_eventID_targetDescriptor_returnID_transactionID = { skipped = true }
setParamDescriptor_forKeyword = { skipped = true }
paramDescriptorForKeyword = { skipped = true }
removeParamDescriptorWithKeyword = { skipped = true }
setAttributeDescriptor_forKeyword = { skipped = true }
attributeDescriptorForKeyword = { skipped = true }
sendEventWithOptions_timeout_error = { skipped = true }
setDescriptor_forKeyword = { skipped = true }
descriptorForKeyword = { skipped = true }
removeDescriptorWithKeyword = { skipped = true }
keywordForDescriptorAtIndex = { skipped = true }
coerceToDescriptorType = { skipped = true }
aeDesc = { skipped = true }
descriptorType = { skipped = true }
eventClass = { skipped = true }
eventID = { skipped = true }
returnID = { skipped = true }
transactionID = { skipped = true }
[class.NSAppleEventManager.methods]
setEventHandler_andSelector_forEventClass_andEventID = { skipped = true }
removeEventHandlerForEventClass_andEventID = { skipped = true }
dispatchRawAppleEvent_withRawReply_handlerRefCon = { skipped = true }
[class.NSOperationQueue.methods.underlyingQueue]
skipped = true
[class.NSOperationQueue.methods.setUnderlyingQueue]
skipped = true
[class.NSRunLoop.methods.getCFRunLoop]
skipped = true
[class.NSURLCredential.methods]
initWithIdentity_certificates_persistence = { skipped = true }
credentialWithIdentity_certificates_persistence = { skipped = true }
initWithTrust = { skipped = true }
credentialForTrust = { skipped = true }
[class.NSURLCredential.methods.identity]
skipped = true
[class.NSURLProtectionSpace.methods.serverTrust]
skipped = true
[class.NSURLSessionConfiguration.methods]
TLSMinimumSupportedProtocol = { skipped = true }
setTLSMinimumSupportedProtocol = { skipped = true }
TLSMaximumSupportedProtocol = { skipped = true }
setTLSMaximumSupportedProtocol = { skipped = true }
TLSMinimumSupportedProtocolVersion = { skipped = true }
setTLSMinimumSupportedProtocolVersion = { skipped = true }
TLSMaximumSupportedProtocolVersion = { skipped = true }
setTLSMaximumSupportedProtocolVersion = { skipped = true }
[class.NSUUID.methods]
initWithUUIDBytes = { skipped = true }
getUUIDBytes = { skipped = true }
[class.NSXPCConnection.methods]
auditSessionIdentifier = { skipped = true }
processIdentifier = { skipped = true }
effectiveUserIdentifier = { skipped = true }
effectiveGroupIdentifier = { skipped = true }
[class.NSXPCInterface.methods]
setXPCType_forSelector_argumentIndex_ofReply = { skipped = true }
XPCTypeForSelector_argumentIndex_ofReply = { skipped = true }
[class.NSXPCCoder.methods]
encodeXPCObject_forKey = { skipped = true }
decodeXPCObjectOfType_forKey = { skipped = true }

# Uses constants from CoreFoundation or similar frameworks
[enum.NSAppleEventSendOptions]
use-value = true
[enum.NSCalendarUnit]
use-value = true
[enum.NSDateFormatterStyle]
use-value = true
[enum.NSRectEdge]
use-value = true
[enum.NSISO8601DateFormatOptions]
use-value = true
[enum.NSLocaleLanguageDirection]
use-value = true
[enum.NSNumberFormatterStyle]
use-value = true
[enum.NSNumberFormatterPadPosition]
use-value = true
[enum.NSNumberFormatterRoundingMode]
use-value = true
[enum.NSPropertyListMutabilityOptions]
use-value = true
[enum.NSPropertyListFormat]
use-value = true
[enum.anonymous.constants.NS_UnknownByteOrder]
skipped = true
[enum.anonymous.constants.NS_LittleEndian]
skipped = true
[enum.anonymous.constants.NS_BigEndian]
skipped = true

# Uses va_list
[class.NSAttributedString.methods.initWithFormat_options_locale_arguments]
skipped = true
[class.NSException.methods.raise_format_arguments]
skipped = true
[class.NSExpression.methods.expressionWithFormat_arguments]
skipped = true
[class.NSPredicate.methods.predicateWithFormat_arguments]
skipped = true
[class.NSString.methods.initWithFormat_arguments]
skipped = true
[class.NSString.methods.initWithFormat_locale_arguments]
skipped = true
[fn.NSLogv]
skipped = true

# Wrong type compared to value
[enum.anonymous.constants.NSWrapCalendarComponents]
skipped = true

# Uses NSImage, which is only available in AppKit
[class.NSUserNotification.methods.contentImage]
skipped = true
[class.NSUserNotification.methods.setContentImage]
skipped = true

# Has the wrong generic parameter
[class.NSDictionary.methods]
initWithContentsOfURL_error = { skipped = true }
dictionaryWithContentsOfURL_error = { skipped = true }

# Protocol class methods (currently unsupported)
[protocol.NSItemProviderWriting.methods.writableTypeIdentifiersForItemProvider]
skipped = true
[protocol.NSItemProviderWriting.methods.itemProviderVisibilityForRepresentationWithTypeIdentifier]
skipped = true
[protocol.NSItemProviderReading.methods.readableTypeIdentifiersForItemProvider]
skipped = true
[protocol.NSItemProviderReading.methods.objectWithItemProviderData_typeIdentifier_error]
skipped = true
[protocol.NSSecureCoding.methods.supportsSecureCoding]
skipped = true

# Custom implementation for now
[struct.NSRange]
skipped = true
[enum.NSComparisonResult]
skipped = true

# We do a custom implementation of these
[protocol.NSCopying]
skipped = true
[protocol.NSMutableCopying]
skipped = true

# Our implementation of superclass methods currently place them in the wrong
# module, so we do this hack for now.
[class.NSMutableAttributedString.methods]
initWithURL_options_documentAttributes_error = { skipped = true }
initWithData_options_documentAttributes_error = { skipped = true }
initWithRTF_documentAttributes = { skipped = true }
initWithRTFD_documentAttributes = { skipped = true }
initWithHTML_documentAttributes = { skipped = true }
initWithHTML_baseURL_documentAttributes = { skipped = true }
initWithDocFormat_documentAttributes = { skipped = true }
initWithHTML_options_documentAttributes = { skipped = true }
initWithRTFDFileWrapper_documentAttributes = { skipped = true }
initWithURL_documentAttributes = { skipped = true }
initWithPath_documentAttributes = { skipped = true }

# Overridden fmt::Debug because we're missing https://github.com/madsmtm/objc2/issues/267
# See fixes/debug.rs
[class.NSAttributedString]
derives = "PartialEq, Eq, Hash"
[class.NSBundle]
derives = "PartialEq, Eq, Hash"
[class.NSThread]
derives = "PartialEq, Eq, Hash"
[class.NSMutableData]
derives = "PartialEq, Eq, Hash"
owned = true
[class.NSMutableArray]
derives = "PartialEq, Eq, Hash"
owned = true
[class.NSMutableAttributedString]
derives = "PartialEq, Eq, Hash"
owned = true
[class.NSMutableSet]
derives = "PartialEq, Eq, Hash"
owned = true
[class.NSMutableString]
derives = "PartialEq, Eq, Hash"
owned = true
[class.NSMutableDictionary]
derives = "PartialEq, Eq, Hash"
owned = true

# Overridden fmt::Debug because it's prettier
[class.NSArray]
derives = "PartialEq, Eq, Hash"
[class.NSData]
derives = "PartialEq, Eq, Hash"
[class.NSDictionary]
derives = "PartialEq, Eq, Hash"
[class.NSError]
derives = "PartialEq, Eq, Hash"
[class.NSException]
derives = "PartialEq, Eq, Hash"
[class.NSProcessInfo]
derives = "PartialEq, Eq, Hash"
[class.NSSet]
derives = "PartialEq, Eq, Hash"
[class.NSString]
derives = "PartialEq, Eq, Hash"
[class.NSUUID]
derives = "PartialEq, Eq, Hash"

# Overridden because whether or not it is Eq depends on the inner value
[class.NSValue]
derives = "Hash"
[class.NSNumber]
derives = "Hash"
[class.NSDecimalNumber]
derives = "Debug, PartialEq, Hash"

# Returns `nil` on Apple and GNUStep throws an exception on all other messages
# to this invalid instance.
[class.NSValue.methods.init]
skipped = true
[class.NSValue.methods.new]
skipped = true

# Returns `NSMyType<T, Shared>` instead of `Self` or `NSMyType<T, O>`
# See fixes/generic_return.rs
[class.NSArray.methods.initWithContentsOfURL_error]
skipped = true
[class.NSArray.methods.initWithContentsOfFile]
skipped = true
[class.NSArray.methods.initWithContentsOfURL]
skipped = true
[class.NSMutableArray.methods.initWithContentsOfFile]
skipped = true
[class.NSMutableArray.methods.initWithContentsOfURL]
skipped = true
[class.NSDictionary.methods.initWithContentsOfFile]
skipped = true
[class.NSDictionary.methods.initWithContentsOfURL]
skipped = true
[class.NSMutableDictionary.methods.initWithContentsOfFile]
skipped = true
[class.NSMutableDictionary.methods.initWithContentsOfURL]
skipped = true

# Manually found to be safe
[class.NSString.methods.init]
unsafe = false
[class.NSString.methods.compare]
unsafe = false
[class.NSString.methods.hasPrefix]
unsafe = false
[class.NSString.methods.hasSuffix]
unsafe = false
[class.NSString.methods.stringByAppendingString]
unsafe = false # The other string is non-null, and won't be retained
[class.NSString.methods.stringByAppendingPathComponent]
unsafe = false
[class.NSString.methods.lengthOfBytesUsingEncoding]
unsafe = false # Assuming `NSStringEncoding` can be made safe
[class.NSString.methods.length]
unsafe = false
[class.NSString.methods.UTF8String]
unsafe = false # Safe to call, but the returned pointer may not be safe to use
[class.NSString.methods.initWithString]
unsafe = false
[class.NSString.methods.stringWithString]
unsafe = false
[class.NSMutableString.methods.initWithCapacity]
unsafe = false
[class.NSMutableString.methods.stringWithCapacity]
unsafe = false
[class.NSMutableString.methods.appendString]
unsafe = false
mutating = true
[class.NSMutableString.methods.setString]
unsafe = false
mutating = true
[class.NSAttributedString.methods.initWithString]
unsafe = false
[class.NSAttributedString.methods.initWithAttributedString]
unsafe = false
[class.NSAttributedString.methods.string]
unsafe = false
[class.NSAttributedString.methods.length]
unsafe = false
[class.NSBundle.methods.mainBundle]
unsafe = false
[class.NSBundle.methods.infoDictionary]
unsafe = false
[class.NSData.methods.length]
unsafe = false
[class.NSData.methods.bytes]
skipped = true
unsafe = false
[class.NSData.methods.initWithData]
unsafe = false
[class.NSData.methods.dataWithData]
unsafe = false
[class.NSDictionary.methods.count]
unsafe = false
[class.NSDictionary.methods.objectForKey]
unsafe = false
[class.NSDictionary.methods.allKeys]
unsafe = false
[class.NSDictionary.methods.allValues]
unsafe = false
[class.NSMutableDictionary.methods.setDictionary]
unsafe = false
mutating = true
[class.NSMutableDictionary.methods.removeObjectForKey]
unsafe = false
mutating = true
[class.NSMutableDictionary.methods.removeAllObjects]
unsafe = false
mutating = true
[class.NSError.methods.domain]
unsafe = false
[class.NSError.methods.code]
unsafe = false
[class.NSError.methods.userInfo]
unsafe = false
[class.NSError.methods.localizedDescription]
unsafe = false
[class.NSException.methods.raise]
skipped = true
[class.NSException.methods.name]
unsafe = false
[class.NSException.methods.reason]
unsafe = false
[class.NSException.methods.userInfo]
unsafe = false
[class.NSLock.methods.name]
unsafe = false
[class.NSLock.methods.setName]
unsafe = false
[class.NSMutableAttributedString.methods.setAttributedString]
unsafe = false
mutating = true
[class.NSMutableData.methods.mutableBytes]
unsafe = false
mutating = true
[class.NSMutableData.methods.length]
skipped = true
[class.NSMutableData.methods.setLength]
unsafe = false
mutating = true
[class.NSMutableData.methods.dataWithCapacity]
unsafe = false
[class.NSMutableData.methods.initWithCapacity]
unsafe = false
[class.NSValue.methods.objCType]
unsafe = false
[class.NSValue.methods.isEqualToValue]
unsafe = false
[class.NSNumber.methods]
initWithChar = { unsafe = false }
initWithUnsignedChar = { unsafe = false }
initWithShort = { unsafe = false }
initWithUnsignedShort = { unsafe = false }
initWithInt = { unsafe = false }
initWithUnsignedInt = { unsafe = false }
initWithLong = { unsafe = false }
initWithUnsignedLong = { unsafe = false }
initWithLongLong = { unsafe = false }
initWithUnsignedLongLong = { unsafe = false }
initWithFloat = { unsafe = false }
initWithDouble = { unsafe = false }
initWithBool = { unsafe = false }
initWithInteger = { unsafe = false }
initWithUnsignedInteger = { unsafe = false }
numberWithChar = { unsafe = false }
numberWithUnsignedChar = { unsafe = false }
numberWithShort = { unsafe = false }
numberWithUnsignedShort = { unsafe = false }
numberWithInt = { unsafe = false }
numberWithUnsignedInt = { unsafe = false }
numberWithLong = { unsafe = false }
numberWithUnsignedLong = { unsafe = false }
numberWithLongLong = { unsafe = false }
numberWithUnsignedLongLong = { unsafe = false }
numberWithFloat = { unsafe = false }
numberWithDouble = { unsafe = false }
numberWithBool = { unsafe = false }
numberWithInteger = { unsafe = false }
numberWithUnsignedInteger = { unsafe = false }
compare = { unsafe = false }
isEqualToNumber = { unsafe = false }
charValue = { unsafe = false }
unsignedCharValue = { unsafe = false }
shortValue = { unsafe = false }
unsignedShortValue = { unsafe = false }
intValue = { unsafe = false }
unsignedIntValue = { unsafe = false }
longValue = { unsafe = false }
unsignedLongValue = { unsafe = false }
longLongValue = { unsafe = false }
unsignedLongLongValue = { unsafe = false }
floatValue = { unsafe = false }
doubleValue = { unsafe = false }
boolValue = { unsafe = false }
integerValue = { unsafe = false }
unsignedIntegerValue = { unsafe = false }
stringValue = { unsafe = false }
[class.NSUUID.methods.UUID]
unsafe = false
[class.NSUUID.methods.init]
unsafe = false
[class.NSUUID.methods.initWithUUIDString]
unsafe = false
[class.NSUUID.methods.UUIDString]
unsafe = false
[class.NSThread.methods.currentThread]
unsafe = false
[class.NSThread.methods.mainThread]
unsafe = false
# [class.NSThread.methods.isMainThread]
# unsafe = false
[class.NSThread.methods.name]
unsafe = false
[class.NSThread.methods.isMultiThreaded]
unsafe = false
[class.NSProcessInfo.methods.processInfo]
unsafe = false
# [class.NSProcessInfo.methods.processName]
# unsafe = false
[class.NSArray.methods.count]
unsafe = false
[class.NSMutableArray.methods.removeAllObjects]
unsafe = false
mutating = true
[class.NSMutableArray.methods.addObject]
mutating = true
[class.NSMutableArray.methods.insertObject_atIndex]
mutating = true
[class.NSMutableArray.methods.replaceObjectAtIndex_withObject]
mutating = true
[class.NSMutableArray.methods.removeObjectAtIndex]
mutating = true
[class.NSMutableArray.methods.removeLastObject]
mutating = true
[class.NSMutableArray.methods.sortUsingFunction_context]
mutating = true
[class.NSSet.methods.count]
unsafe = false
[class.NSMutableSet.methods.removeAllObjects]
unsafe = false
mutating = true
[class.NSMutableSet.methods.addObject]
mutating = true

# Mutable classes
#
# Some of these are commented out because they're set above
# [class.NSMutableArray]
# owned = true
[class.NSMutableCharacterSet]
owned = true
# [class.NSMutableData]
# owned = true
# [class.NSMutableDictionary]
# owned = true
# [class.NSMutableSet]
# owned = true
[class.NSMutableOrderedSet]
owned = true
[class.NSMutableIndexSet]
owned = true
# [class.NSMutableString]
# owned = true
# [class.NSMutableAttributedString]
# owned = true
[class.NSMutableURLRequest]
owned = true
