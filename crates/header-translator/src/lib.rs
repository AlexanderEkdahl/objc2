use std::collections::{BTreeMap, HashSet};
use std::fmt::{Display, Write};
use std::path::Path;
use std::process::{Command, Stdio};

mod availability;
mod config;
mod expr;
mod method;
mod objc2_utils;
mod property;
mod rust_type;
mod stmt;
mod unexposed_macro;

pub use self::config::Config;
pub use self::stmt::Stmt;

#[derive(Debug, PartialEq)]
pub struct RustFile {
    declared_types: HashSet<String>,
    stmts: Vec<Stmt>,
}

pub const FILE_PRELUDE: &str = r#"//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT"#;

const INITIAL_IMPORTS: &str = r#"use crate::common::*;"#;

impl RustFile {
    pub fn new() -> Self {
        Self {
            declared_types: HashSet::new(),
            stmts: Vec::new(),
        }
    }

    pub fn add_stmt(&mut self, stmt: Stmt) {
        match &stmt {
            Stmt::ClassDecl { ty, .. } => {
                self.declared_types.insert(ty.name.clone());
            }
            Stmt::CategoryDecl { .. } => {}
            Stmt::ProtocolDecl { name, .. } => {
                self.declared_types.insert(name.clone());
            }
            Stmt::StructDecl { name, .. } => {
                self.declared_types.insert(name.clone());
            }
            Stmt::EnumDecl { name, variants, .. } => {
                if let Some(name) = name {
                    self.declared_types.insert(name.clone());
                }
                for (name, _) in variants {
                    self.declared_types.insert(name.clone());
                }
            }
            Stmt::VarDecl { name, .. } => {
                self.declared_types.insert(name.clone());
            }
            Stmt::FnDecl { name, body, .. } => {
                if body.is_none() {
                    self.declared_types.insert(name.clone());
                } else {
                    // TODO
                }
            }
            Stmt::AliasDecl { name, .. } => {
                self.declared_types.insert(name.clone());
            }
        }
        self.stmts.push(stmt);
    }

    pub fn finish(self, config: &Config) -> (HashSet<String>, String) {
        let mut tokens = String::new();
        writeln!(tokens, "{}", FILE_PRELUDE).unwrap();
        writeln!(tokens, "{}", INITIAL_IMPORTS).unwrap();

        for import in &config.imports {
            writeln!(tokens, "use crate::{import}::*;").unwrap();
        }

        writeln!(tokens, "").unwrap();

        for stmt in self.stmts {
            writeln!(tokens, "{}", stmt).unwrap();
        }

        (self.declared_types, tokens)
    }

    pub fn compare(&self, other: &Self) {
        compare_vec(&self.stmts, &other.stmts, |_i, self_stmt, other_stmt| {
            self_stmt.compare(other_stmt);
        });
    }
}

pub fn compare_btree<T>(
    data1: &BTreeMap<String, T>,
    data2: &BTreeMap<String, T>,
    f: impl Fn(&str, &T, &T),
) {
    for (key1, item1) in data1 {
        let item2 = data2
            .get(key1)
            .unwrap_or_else(|| panic!("did not find key {key1} in data2"));
        f(&key1, item1, item2);
    }
    assert_eq!(data1.len(), data2.len(), "too few items in first map");
}

pub fn compare_vec<T: core::fmt::Debug>(data1: &Vec<T>, data2: &Vec<T>, f: impl Fn(usize, &T, &T)) {
    let mut iter2 = data1.iter();
    for (i, item1) in data2.iter().enumerate() {
        if let Some(item2) = iter2.next() {
            f(i, item1, item2);
        } else {
            panic!("no more statements in second vec at index {i}");
        }
    }
    let remaining: Vec<_> = iter2.collect();
    if remaining.len() != 0 {
        panic!("remaining statements in second vec: {remaining:#?}");
    }
}

pub fn run_cargo_fmt(package: &str) {
    let status = Command::new("cargo")
        .args(["fmt", "--package", package])
        .current_dir(Path::new(env!("CARGO_MANIFEST_DIR")).parent().unwrap())
        .status()
        .expect("failed running cargo fmt");

    assert!(
        status.success(),
        "failed running cargo fmt with exit code {status}"
    );
}

pub fn run_rustfmt(data: impl Display) -> Vec<u8> {
    use std::io::Write;

    let mut child = Command::new("rustfmt")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("failed running rustfmt");

    let mut stdin = child.stdin.take().expect("failed to open stdin");
    write!(stdin, "{}", data).expect("failed writing");
    drop(stdin);

    let output = child.wait_with_output().expect("failed formatting");

    if !output.status.success() {
        panic!("failed running rustfmt with exit code {}", output.status)
    }

    output.stdout
}
