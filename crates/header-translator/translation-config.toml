[library.Foundation]
imports = ["Foundation"]

[library.CoreData]
imports = ["CoreData", "Foundation"]

[library.AppKit]
imports = ["AppKit", "CoreData", "Foundation"]

[library.AuthenticationServices]
imports = ["AuthenticationServices", "Foundation"]

# Uses NS_REPLACES_RECEIVER
[class.NSObject.methods.awakeAfterUsingCoder]
skipped = true

[protocol.NSKeyedUnarchiverDelegate.methods]
# Uses NS_RELEASES_ARGUMENT and NS_RETURNS_RETAINED
unarchiver_didDecodeObject = { skipped = true }

[class.NSBlockOperation.methods]
# Uses `NSArray<void (^)(void)>`, which is difficult to handle
executionBlocks = { skipped = true }

# These use `Class<NSItemProvider...>`, which is unsupported
[class.NSItemProvider.methods]
registerObjectOfClass_visibility_loadHandler = { skipped = true }
canLoadObjectOfClass = { skipped = true }
loadObjectOfClass_completionHandler = { skipped = true }

# These use `SomeObject * __strong *`, which is unsupported
[class.NSNetService.methods]
getInputStream_outputStream = { skipped = true }
[class.NSPropertyListSerialization.methods]
dataFromPropertyList_format_errorDescription = { skipped = true }
propertyListFromData_mutabilityOption_format_errorDescription = { skipped = true }

# Has `error:` parameter, but returns NSInteger (where 0 means error)
[class.NSJSONSerialization.methods.writeJSONObject_toStream_options_error]
skipped = true
[class.NSPropertyListSerialization.methods.writePropertyList_toStream_format_options_error]
skipped = true
[class.NSManagedObjectContext.methods]
countForFetchRequest_error = { skipped = true }

# Not supported on clang 11.0.0
[class.NSBundle.methods.localizedAttributedStringForKey_value_table]
skipped = true

# Both instance and class methods
[class.NSUnarchiver.methods.decodeClassName_asClassName]
skipped = true
[class.NSUnarchiver.methods.classNameDecodedForArchiveClassName]
skipped = true
[class.NSAutoreleasePool.methods.addObject]
skipped = true
[class.NSBundle.methods.pathForResource_ofType_inDirectory]
skipped = true
[class.NSBundle.methods.pathsForResourcesOfType_inDirectory]
skipped = true
[class.NSKeyedArchiver.methods.setClassName_forClass]
skipped = true
[class.NSKeyedArchiver.methods.classNameForClass]
skipped = true
[class.NSKeyedUnarchiver.methods.setClass_forClassName]
skipped = true
[class.NSKeyedUnarchiver.methods.classForClassName]
skipped = true
[class.NSThread.methods.threadPriority]
skipped = true
[class.NSThread.methods.setThreadPriority]
skipped = true
[class.NSThread.methods.isMainThread]
skipped = true
[class.NSDate.methods.timeIntervalSinceReferenceDate]
skipped = true
[class.NSManagedObject.methods.entity]
skipped = true
[class.NSCursor.methods.pop]
skipped = true
[class.NSEvent.methods.modifierFlags]
skipped = true
[class.NSGraphicsContext.methods.saveGraphicsState]
skipped = true
[class.NSGraphicsContext.methods.restoreGraphicsState]
skipped = true
[class.NSBundle.methods.loadNibFile_externalNameTable_withZone]
skipped = true

# Root class
[class.NSProxy]
definition-skipped = true
[class.NSProxy.methods]
alloc = { skipped = true }
allocWithZone = { skipped = true }

# Ignore categories on NSObject for now
[class.NSObject]
skipped = true

# Contains bitfields
[struct.NSDecimal]
skipped = true

# Uses stuff from core Darwin libraries which we have not yet mapped
[class.NSAppleEventDescriptor.methods]
descriptorWithDescriptorType_bytes_length = { skipped = true }
descriptorWithDescriptorType_data = { skipped = true }
appleEventWithEventClass_eventID_targetDescriptor_returnID_transactionID = { skipped = true }
descriptorWithProcessIdentifier = { skipped = true }
initWithAEDescNoCopy = { skipped = true }
initWithDescriptorType_bytes_length = { skipped = true }
initWithDescriptorType_data = { skipped = true }
initWithEventClass_eventID_targetDescriptor_returnID_transactionID = { skipped = true }
setParamDescriptor_forKeyword = { skipped = true }
paramDescriptorForKeyword = { skipped = true }
removeParamDescriptorWithKeyword = { skipped = true }
setAttributeDescriptor_forKeyword = { skipped = true }
attributeDescriptorForKeyword = { skipped = true }
sendEventWithOptions_timeout_error = { skipped = true }
setDescriptor_forKeyword = { skipped = true }
descriptorForKeyword = { skipped = true }
removeDescriptorWithKeyword = { skipped = true }
keywordForDescriptorAtIndex = { skipped = true }
coerceToDescriptorType = { skipped = true }
aeDesc = { skipped = true }
descriptorType = { skipped = true }
eventClass = { skipped = true }
eventID = { skipped = true }
returnID = { skipped = true }
transactionID = { skipped = true }
[class.NSAppleEventManager.methods]
setEventHandler_andSelector_forEventClass_andEventID = { skipped = true }
removeEventHandlerForEventClass_andEventID = { skipped = true }
dispatchRawAppleEvent_withRawReply_handlerRefCon = { skipped = true }
[class.NSOperationQueue.methods.underlyingQueue]
skipped = true
[class.NSOperationQueue.methods.setUnderlyingQueue]
skipped = true
[class.NSRunLoop.methods.getCFRunLoop]
skipped = true
[class.NSURLCredential.methods]
initWithIdentity_certificates_persistence = { skipped = true }
credentialWithIdentity_certificates_persistence = { skipped = true }
initWithTrust = { skipped = true }
credentialForTrust = { skipped = true }
[class.NSURLCredential.methods.identity]
skipped = true
[class.NSURLProtectionSpace.methods.serverTrust]
skipped = true
[class.NSURLSessionConfiguration.methods]
TLSMinimumSupportedProtocol = { skipped = true }
setTLSMinimumSupportedProtocol = { skipped = true }
TLSMaximumSupportedProtocol = { skipped = true }
setTLSMaximumSupportedProtocol = { skipped = true }
TLSMinimumSupportedProtocolVersion = { skipped = true }
setTLSMinimumSupportedProtocolVersion = { skipped = true }
TLSMaximumSupportedProtocolVersion = { skipped = true }
setTLSMaximumSupportedProtocolVersion = { skipped = true }
[class.NSUUID.methods]
initWithUUIDBytes = { skipped = true }
getUUIDBytes = { skipped = true }
[class.NSXPCConnection.methods]
auditSessionIdentifier = { skipped = true }
processIdentifier = { skipped = true }
effectiveUserIdentifier = { skipped = true }
effectiveGroupIdentifier = { skipped = true }
[class.NSXPCInterface.methods]
setXPCType_forSelector_argumentIndex_ofReply = { skipped = true }
XPCTypeForSelector_argumentIndex_ofReply = { skipped = true }
[class.NSXPCCoder.methods]
encodeXPCObject_forKey = { skipped = true }
decodeXPCObjectOfType_forKey = { skipped = true }

# Uses constants from CoreFoundation or similar frameworks
[enum.NSAppleEventSendOptions]
use-value = true
[enum.NSCalendarUnit]
use-value = true
[enum.NSDateFormatterStyle]
use-value = true
[enum.NSISO8601DateFormatOptions]
use-value = true
[enum.NSLocaleLanguageDirection]
use-value = true
[enum.NSNumberFormatterStyle]
use-value = true
[enum.NSNumberFormatterPadPosition]
use-value = true
[enum.NSNumberFormatterRoundingMode]
use-value = true
[enum.NSPropertyListMutabilityOptions]
use-value = true
[enum.NSPropertyListFormat]
use-value = true
[enum.anonymous.constants.NS_UnknownByteOrder]
skipped = true
[enum.anonymous.constants.NS_LittleEndian]
skipped = true
[enum.anonymous.constants.NS_BigEndian]
skipped = true

# Uses va_list
[class.NSAttributedString.methods.initWithFormat_options_locale_arguments]
skipped = true
[class.NSException.methods.raise_format_arguments]
skipped = true
[class.NSExpression.methods.expressionWithFormat_arguments]
skipped = true
[class.NSPredicate.methods.predicateWithFormat_arguments]
skipped = true
[class.NSString.methods.initWithFormat_arguments]
skipped = true
[class.NSString.methods.initWithFormat_locale_arguments]
skipped = true
[fn.NSLogv]
skipped = true

# Wrong type compared to value
[enum.anonymous.constants.NSWrapCalendarComponents]
skipped = true

# Uses NSImage, which is only available in AppKit
[class.NSUserNotification.methods.contentImage]
skipped = true
[class.NSUserNotification.methods.setContentImage]
skipped = true

# Outlier that really should have been part of the original enum
[enum.anonymous.constants.NSProprietaryStringEncoding]
skipped = true

# Has the wrong generic parameter
[class.NSDictionary.methods]
initWithContentsOfURL_error = { skipped = true }
dictionaryWithContentsOfURL_error = { skipped = true }

# Protocol class methods (currently unsupported)
[protocol.NSItemProviderWriting.methods.writableTypeIdentifiersForItemProvider]
skipped = true
[protocol.NSItemProviderWriting.methods.itemProviderVisibilityForRepresentationWithTypeIdentifier]
skipped = true
[protocol.NSItemProviderReading.methods.readableTypeIdentifiersForItemProvider]
skipped = true
[protocol.NSItemProviderReading.methods.objectWithItemProviderData_typeIdentifier_error]
skipped = true
[protocol.NSSecureCoding.methods.supportsSecureCoding]
skipped = true
[protocol.NSAnimatablePropertyContainer.methods.defaultAnimationForKey]
skipped = true
[protocol.NSPasteboardReading.methods.readableTypesForPasteboard]
skipped = true
[protocol.NSPasteboardReading.methods.readingOptionsForType_pasteboard]
skipped = true
[protocol.NSWindowRestoration.methods.restoreWindowWithIdentifier_state_completionHandler]
skipped = true

# Custom implementation for now
[struct.NSRange]
skipped = true
[enum.NSComparisonResult]
skipped = true

# Different definitions on 32-bit
[typedef.NSPoint]
skipped = true
[struct.NSPoint]
skipped = true
[typedef.NSSize]
skipped = true
[struct.NSSize]
skipped = true
[typedef.NSRect]
skipped = true
[struct.NSRect]
skipped = true
[enum.NSRectEdge]
skipped = true
[enum.anonymous.constants.NSRectEdgeMinX]
skipped = true
[enum.anonymous.constants.NSRectEdgeMinY]
skipped = true
[enum.anonymous.constants.NSRectEdgeMaxX]
skipped = true
[enum.anonymous.constants.NSRectEdgeMaxY]
skipped = true
[enum.anonymous.constants.NSMinXEdge]
skipped = true
[enum.anonymous.constants.NSMinYEdge]
skipped = true
[enum.anonymous.constants.NSMaxXEdge]
skipped = true
[enum.anonymous.constants.NSMaxYEdge]
skipped = true

# We do a custom implementation of these
[protocol.NSCopying]
skipped = true
[protocol.NSMutableCopying]
skipped = true

# Our implementation of superclass methods currently place them in the wrong
# module, so we do this hack for now.
[class.NSMutableAttributedString.methods]
initWithURL_options_documentAttributes_error = { skipped = true }
initWithData_options_documentAttributes_error = { skipped = true }
initWithRTF_documentAttributes = { skipped = true }
initWithRTFD_documentAttributes = { skipped = true }
initWithHTML_documentAttributes = { skipped = true }
initWithHTML_baseURL_documentAttributes = { skipped = true }
initWithDocFormat_documentAttributes = { skipped = true }
initWithHTML_options_documentAttributes = { skipped = true }
initWithRTFDFileWrapper_documentAttributes = { skipped = true }
initWithURL_documentAttributes = { skipped = true }
initWithPath_documentAttributes = { skipped = true }

# Uses a bit of complex feature testing setup, see ASFoundation.h
[typedef.ASPresentationAnchor]
skipped = true
[typedef.ASViewController]
skipped = true
[typedef.ASImage]
skipped = true

# The original superclass typedef is a bit difficult to extract from the
# superclass name, so let's just overwrite it.
[class.ASCredentialProviderViewController]
definition-skipped = true
[class.ASAccountAuthenticationModificationViewController]
definition-skipped = true

# Specifies superclass as UIControl or NSControl conditionally
[class.ASAuthorizationAppleIDButton]
definition-skipped = true

# Defined in multiple files
[static.NSErrorMergePolicy]
skipped = true
[static.NSMergeByPropertyObjectTrumpMergePolicy]
skipped = true
[static.NSMergeByPropertyStoreTrumpMergePolicy]
skipped = true
[static.NSOverwriteMergePolicy]
skipped = true
[static.NSRollbackMergePolicy]
skipped = true

# Works weirdly since it's defined both as a property, and as a method.
[class.NSDocument.methods.setDisplayName]
skipped = true

# These return `oneway void`, which is a bit tricky to handle.
[class.NSPasteboard.methods.releaseGlobally]
skipped = true
[class.NSView.methods.releaseGState]
skipped = true

# Typedef that uses a generic from a class
[typedef.NSCollectionViewDiffableDataSourceItemProvider]
skipped = true
[class.NSCollectionViewDiffableDataSource.methods.initWithCollectionView_itemProvider]
skipped = true

# Both protocols and classes
[protocol.NSTextAttachmentCell]
skipped = true
[protocol.NSAccessibilityElement]
skipped = true

# Both property and method
[class.NSDrawer.methods.open]
skipped = true
[class.NSDrawer.methods.close]
skipped = true
[class.NSFormCell.methods.titleWidth]
skipped = true
[class.NSSliderCell.methods.drawKnob]
skipped = true
[class.NSWorkspace.methods.noteFileSystemChanged]
skipped = true

# Duplicated method
[class.NSSlider.methods.isVertical]
skipped = true
[class.NSSliderCell.methods.isVertical]
skipped = true
[class.NSGestureRecognizer.methods.state]
skipped = true

# Uses stuff from different frameworks / system libraries
[class.NSAnimationContext.methods.timingFunction]
skipped = true
[class.NSAnimationContext.methods.setTimingFunction]
skipped = true
[class.NSBezierPath.methods.appendBezierPathWithCGGlyph_inFont]
skipped = true
[class.NSBezierPath.methods.appendBezierPathWithCGGlyphs_count_inFont]
skipped = true
[class.NSBitmapImageRep.methods.initWithCGImage]
skipped = true
[class.NSBitmapImageRep.methods.initWithCIImage]
skipped = true
[class.NSBitmapImageRep.methods.CGImage]
skipped = true
[class.NSColor.methods.CGColor]
skipped = true
[class.NSColor.methods.colorWithCGColor]
skipped = true
[class.NSColor.methods.colorWithCIColor]
skipped = true
[class.NSColorSpace.methods.initWithCGColorSpace]
skipped = true
[class.NSColorSpace.methods.CGColorSpace]
skipped = true
[class.NSCIImageRep]
skipped = true
[class.NSEvent.methods.CGEvent]
skipped = true
[class.NSEvent.methods.eventWithCGEvent]
skipped = true
[class.NSFont.methods]
boundingRectForCGGlyph = { skipped = true }
advancementForCGGlyph = { skipped = true }
getBoundingRects_forCGGlyphs_count = { skipped = true }
getAdvancements_forCGGlyphs_count = { skipped = true }
[class.NSGlyphInfo.methods.glyphInfoWithCGGlyph_forFont_baseString]
skipped = true
[class.NSGlyphInfo.methods.glyphID]
skipped = true
[class.NSGraphicsContext.methods.graphicsContextWithCGContext_flipped]
skipped = true
[class.NSGraphicsContext.methods.CGContext]
skipped = true
[class.NSGraphicsContext.methods.CIContext]
skipped = true
[class.NSImage.methods]
initWithCGImage_size = { skipped = true }
CGImageForProposedRect_context_hints = { skipped = true }
initWithIconRef = { skipped = true }
[class.NSImageRep.methods.CGImageForProposedRect_context_hints]
skipped = true
[class.NSItemProvider.methods.registerCloudKitShareWithPreparationHandler]
skipped = true
[class.NSItemProvider.methods.registerCloudKitShare_container]
skipped = true
[class.NSLayoutManager.methods]
setGlyphs_properties_characterIndexes_font_forGlyphRange = { skipped = true }
CGGlyphAtIndex_isValidIndex = { skipped = true }
CGGlyphAtIndex = { skipped = true }
getGlyphsInRange_glyphs_properties_characterIndexes_bidiLevels = { skipped = true }
glyphIndexForPoint_inTextContainer_fractionOfDistanceThroughGlyph = { skipped = true }
showCGGlyphs_positions_count_font_textMatrix_attributes_inContext = { skipped = true }
showCGGlyphs_positions_count_font_matrix_attributes_inContext = { skipped = true }
[class.NSLayoutManagerDelegate.methods.layoutManager_shouldGenerateGlyphs_properties_characterIndexes_font_forGlyphRange]
skipped = true
[class.NSMovie.methods.initWithMovie]
skipped = true
[class.NSMovie.methods.QTMovie]
skipped = true
[class.NSOpenGLContext]
skipped = true
[class.NSOpenGLLayer]
skipped = true
[class.NSOpenGLPixelFormat]
skipped = true
[class.NSOpenGLPixelBuffer]
skipped = true
[class.NSOpenGLView]
skipped = true
[fn.NSOpenGLSetOption]
skipped = true
[fn.NSOpenGLGetOption]
skipped = true
[fn.NSOpenGLGetVersion]
skipped = true
[class.NSTextLayoutFragment.methods.drawAtPoint_inContext]
skipped = true
[class.NSTextLineFragment.methods.drawAtPoint_inContext]
skipped = true
[class.NSTextView.methods.quickLookPreviewableItemsInRanges]
skipped = true
[class.NSRunningApplication.methods.processIdentifier]
skipped = true
[class.NSRunningApplication.methods.runningApplicationWithProcessIdentifier]
skipped = true
[class.NSSavePanel.methods.allowedContentTypes]
skipped = true
[class.NSSavePanel.methods.setAllowedContentTypes]
skipped = true
[class.NSView.methods]
layer = { skipped = true }
setLayer = { skipped = true }
backgroundFilters = { skipped = true }
setBackgroundFilters = { skipped = true }
compositingFilter = { skipped = true }
setCompositingFilter = { skipped = true }
contentFilters = { skipped = true }
setContentFilters = { skipped = true }
makeBackingLayer = { skipped = true }
[class.NSObject.methods.layer_shouldInheritContentsScale_fromWindow]
skipped = true
[class.NSWorkspace.methods]
iconForContentType = { skipped = true }
URLForApplicationToOpenContentType = { skipped = true }
URLsForApplicationsToOpenContentType = { skipped = true }
setDefaultApplicationAtURL_toOpenContentType_completionHandler = { skipped = true }
[class.NSWorkspaceOpenConfiguration.methods.architecture]
skipped = true
[class.NSWorkspaceOpenConfiguration.methods.setArchitecture]
skipped = true
[protocol.NSApplicationDelegate.methods]
application_handlerForIntent = { skipped = true }
application_userDidAcceptCloudKitShareWithMetadata = { skipped = true }
[protocol.NSLayoutManagerDelegate.methods]
layoutManager_shouldGenerateGlyphs_properties_characterIndexes_font_forGlyphRange = { skipped = true }
[protocol.NSCloudSharingServiceDelegate.methods]
sharingService_didSaveShare = { skipped = true }
sharingService_didStopSharing = { skipped = true }
[protocol.NSCloudSharingValidation]
skipped = true
[protocol.NSViewLayerContentScaleDelegate]
skipped = true
[class.NSCoreDataCoreSpotlightDelegate.methods]
attributeSetForObject = { skipped = true }
searchableIndex_reindexAllSearchableItemsWithAcknowledgementHandler = { skipped = true }
searchableIndex_reindexSearchableItemsWithIdentifiers_acknowledgementHandler = { skipped = true }
[class.NSPersistentCloudKitContainer.methods]
recordForManagedObjectID = { skipped = true }
recordsForManagedObjectIDs = { skipped = true }
recordIDForManagedObjectID = { skipped = true }
recordIDsForManagedObjectIDs = { skipped = true }
[class.NSPersistentCloudKitContainerOptions.methods]
databaseScope = { skipped = true }
setDatabaseScope = { skipped = true }
[protocol.NSFetchedResultsControllerDelegate.methods]
controller_didChangeContentWithSnapshot = { skipped = true }

# Uses a pointer to SEL, which doesn't implement Encode yet
[protocol.NSMenuDelegate.methods]
menuHasKeyEquivalent_forEvent_target_action = { skipped = true }

# These subclass a generic struct, and hence the type parameter defaults to
# `Object`, which is not PartialEq, Eq nor Hash.
[class.NSLayoutXAxisAnchor]
derives = "Debug"
[class.NSLayoutYAxisAnchor]
derives = "Debug"
[class.NSLayoutDimension]
derives = "Debug"

# Wrong type for enum
[enum.anonymous.constants]
NSOKButton = { skipped = true }
NSCancelButton = { skipped = true }
NSFileHandlingPanelCancelButton = { skipped = true }
NSFileHandlingPanelOKButton = { skipped = true }

# Categories for classes defined in other frameworks
[class.CIImage]
skipped = true
[class.CIColor]
skipped = true

# Different definitions depending on target
[enum.NSImageResizingMode]
skipped = true
[enum.NSTextAlignment]
skipped = true

# Different definitions depending on deployment target
[class.NSLayoutAnchor]
definition-skipped = true
[class.NSPopover]
definition-skipped = true
[class.NSPopover.methods]
appearance = { skipped = true }
setAppearance = { skipped = true }
effectiveAppearance = { skipped = true }

# I'm unsure of the ABI of the array this takes
[fn.NSDrawBitmap]
skipped = true
[class.NSView.methods.getRectsExposedDuringLiveResize_count]
skipped = true

# Overridden fmt::Debug because we're missing https://github.com/madsmtm/objc2/issues/267
# See fixes/debug.rs
[class.NSAttributedString]
derives = "PartialEq, Eq, Hash"
[class.NSBundle]
derives = "PartialEq, Eq, Hash"
[class.NSThread]
derives = "PartialEq, Eq, Hash"
[class.NSMutableData]
derives = "PartialEq, Eq, Hash"
owned = true
[class.NSMutableArray]
derives = "PartialEq, Eq, Hash"
owned = true
[class.NSMutableAttributedString]
derives = "PartialEq, Eq, Hash"
owned = true
[class.NSMutableSet]
derives = "PartialEq, Eq, Hash"
owned = true
[class.NSMutableString]
derives = "PartialEq, Eq, Hash"
owned = true
[class.NSMutableDictionary]
derives = "PartialEq, Eq, Hash"
owned = true

# Overridden fmt::Debug because it's prettier
[class.NSArray]
derives = "PartialEq, Eq, Hash"
[class.NSData]
derives = "PartialEq, Eq, Hash"
[class.NSDictionary]
derives = "PartialEq, Eq, Hash"
[class.NSError]
derives = "PartialEq, Eq, Hash"
[class.NSException]
derives = "PartialEq, Eq, Hash"
[class.NSProcessInfo]
derives = "PartialEq, Eq, Hash"
[class.NSSet]
derives = "PartialEq, Eq, Hash"
[class.NSString]
derives = "PartialEq, Eq, Hash"
[class.NSUUID]
derives = "PartialEq, Eq, Hash"

# Overridden because whether or not it is Eq depends on the inner value
[class.NSValue]
derives = ""
[class.NSNumber]
derives = ""
[class.NSDecimalNumber]
derives = "Debug, PartialEq, Hash"

# Returns `nil` on Apple and GNUStep throws an exception on all other messages
# to this invalid instance.
[class.NSValue.methods.init]
skipped = true
[class.NSValue.methods.new]
skipped = true

# Returns `NSMyType<T, Shared>` instead of `Self` or `NSMyType<T, O>`
# See fixes/generic_return.rs
[class.NSArray.methods.initWithContentsOfURL_error]
skipped = true
[class.NSArray.methods.initWithContentsOfFile]
skipped = true
[class.NSArray.methods.initWithContentsOfURL]
skipped = true
[class.NSMutableArray.methods.initWithContentsOfFile]
skipped = true
[class.NSMutableArray.methods.initWithContentsOfURL]
skipped = true
[class.NSDictionary.methods.initWithContentsOfFile]
skipped = true
[class.NSDictionary.methods.initWithContentsOfURL]
skipped = true
[class.NSMutableDictionary.methods.initWithContentsOfFile]
skipped = true
[class.NSMutableDictionary.methods.initWithContentsOfURL]
skipped = true

# Manually found to be safe
[class.NSString.methods.init]
unsafe = false
[class.NSString.methods.compare]
unsafe = false
[class.NSString.methods.hasPrefix]
unsafe = false
[class.NSString.methods.hasSuffix]
unsafe = false
[class.NSString.methods.stringByAppendingString]
unsafe = false # The other string is non-null, and won't be retained
[class.NSString.methods.stringByAppendingPathComponent]
unsafe = false
[class.NSString.methods.lengthOfBytesUsingEncoding]
unsafe = false # Assuming `NSStringEncoding` can be made safe
[class.NSString.methods.length]
unsafe = false
[class.NSString.methods.UTF8String]
unsafe = false # Safe to call, but the returned pointer may not be safe to use
[class.NSString.methods.initWithString]
unsafe = false
[class.NSString.methods.stringWithString]
unsafe = false
[class.NSMutableString.methods.initWithCapacity]
unsafe = false
[class.NSMutableString.methods.stringWithCapacity]
unsafe = false
[class.NSMutableString.methods.initWithString]
unsafe = false
[class.NSMutableString.methods.stringWithString]
unsafe = false
[class.NSMutableString.methods.appendString]
unsafe = false
mutating = true
[class.NSMutableString.methods.setString]
unsafe = false
mutating = true
[class.NSAttributedString.methods.initWithString]
unsafe = false
[class.NSAttributedString.methods.initWithAttributedString]
unsafe = false
[class.NSMutableAttributedString.methods.initWithString]
unsafe = false
[class.NSMutableAttributedString.methods.initWithAttributedString]
unsafe = false
[class.NSAttributedString.methods.string]
unsafe = false
[class.NSAttributedString.methods.length]
unsafe = false
[class.NSBundle.methods.mainBundle]
unsafe = false
[class.NSBundle.methods.infoDictionary]
unsafe = false
[class.NSData.methods.length]
unsafe = false
[class.NSData.methods.bytes]
skipped = true
unsafe = false
[class.NSData.methods.initWithData]
unsafe = false
[class.NSData.methods.dataWithData]
unsafe = false
[class.NSDictionary.methods.count]
unsafe = false
[class.NSDictionary.methods.objectForKey]
unsafe = false
[class.NSDictionary.methods.allKeys]
unsafe = false
[class.NSDictionary.methods.allValues]
unsafe = false
[class.NSMutableDictionary.methods.setDictionary]
unsafe = false
mutating = true
[class.NSMutableDictionary.methods.removeObjectForKey]
unsafe = false
mutating = true
[class.NSMutableDictionary.methods.removeAllObjects]
unsafe = false
mutating = true
[class.NSError.methods.domain]
unsafe = false
[class.NSError.methods.code]
unsafe = false
[class.NSError.methods.userInfo]
unsafe = false
[class.NSError.methods.localizedDescription]
unsafe = false
[class.NSException.methods.raise]
skipped = true
[class.NSException.methods.name]
unsafe = false
[class.NSException.methods.reason]
unsafe = false
[class.NSException.methods.userInfo]
unsafe = false
[class.NSLock.methods.name]
unsafe = false
[class.NSLock.methods.setName]
unsafe = false
[class.NSMutableAttributedString.methods.setAttributedString]
unsafe = false
mutating = true
[class.NSMutableData.methods.mutableBytes]
unsafe = false
mutating = true
skipped = true # Wrong type on GNUStep
[class.NSMutableData.methods.length]
skipped = true
[class.NSMutableData.methods.setLength]
unsafe = false
mutating = true
[class.NSMutableData.methods.dataWithCapacity]
unsafe = false
[class.NSMutableData.methods.initWithCapacity]
unsafe = false
[class.NSMutableData.methods.dataWithData]
unsafe = false
[class.NSValue.methods.objCType]
unsafe = false
[class.NSValue.methods.isEqualToValue]
unsafe = false
[class.NSNumber.methods]
initWithChar = { unsafe = false }
initWithUnsignedChar = { unsafe = false }
initWithShort = { unsafe = false }
initWithUnsignedShort = { unsafe = false }
initWithInt = { unsafe = false }
initWithUnsignedInt = { unsafe = false }
initWithLong = { unsafe = false }
initWithUnsignedLong = { unsafe = false }
initWithLongLong = { unsafe = false }
initWithUnsignedLongLong = { unsafe = false }
initWithFloat = { unsafe = false }
initWithDouble = { unsafe = false }
initWithBool = { unsafe = false }
initWithInteger = { unsafe = false }
initWithUnsignedInteger = { unsafe = false }
numberWithChar = { unsafe = false }
numberWithUnsignedChar = { unsafe = false }
numberWithShort = { unsafe = false }
numberWithUnsignedShort = { unsafe = false }
numberWithInt = { unsafe = false }
numberWithUnsignedInt = { unsafe = false }
numberWithLong = { unsafe = false }
numberWithUnsignedLong = { unsafe = false }
numberWithLongLong = { unsafe = false }
numberWithUnsignedLongLong = { unsafe = false }
numberWithFloat = { unsafe = false }
numberWithDouble = { unsafe = false }
numberWithBool = { unsafe = false }
numberWithInteger = { unsafe = false }
numberWithUnsignedInteger = { unsafe = false }
compare = { unsafe = false }
isEqualToNumber = { unsafe = false }
charValue = { unsafe = false }
unsignedCharValue = { unsafe = false }
shortValue = { unsafe = false }
unsignedShortValue = { unsafe = false }
intValue = { unsafe = false }
unsignedIntValue = { unsafe = false }
longValue = { unsafe = false }
unsignedLongValue = { unsafe = false }
longLongValue = { unsafe = false }
unsignedLongLongValue = { unsafe = false }
floatValue = { unsafe = false }
doubleValue = { unsafe = false }
boolValue = { unsafe = false }
integerValue = { unsafe = false }
unsignedIntegerValue = { unsafe = false }
stringValue = { unsafe = false }
[class.NSUUID.methods.UUID]
unsafe = false
[class.NSUUID.methods.init]
unsafe = false
[class.NSUUID.methods.initWithUUIDString]
unsafe = false
[class.NSUUID.methods.UUIDString]
unsafe = false
[class.NSThread.methods.currentThread]
unsafe = false
[class.NSThread.methods.mainThread]
unsafe = false
# [class.NSThread.methods.isMainThread]
# unsafe = false
[class.NSThread.methods.name]
unsafe = false
[class.NSThread.methods.isMultiThreaded]
unsafe = false
[class.NSProcessInfo.methods.processInfo]
unsafe = false
[class.NSProcessInfo.methods.processName]
unsafe = false
[class.NSArray.methods.count]
unsafe = false
[class.NSMutableArray.methods.removeAllObjects]
unsafe = false
mutating = true
[class.NSMutableArray.methods.addObject]
mutating = true
[class.NSMutableArray.methods.insertObject_atIndex]
mutating = true
[class.NSMutableArray.methods.replaceObjectAtIndex_withObject]
mutating = true
[class.NSMutableArray.methods.removeObjectAtIndex]
mutating = true
[class.NSMutableArray.methods.removeLastObject]
mutating = true
[class.NSMutableArray.methods.sortUsingFunction_context]
mutating = true
[class.NSSet.methods.count]
unsafe = false
[class.NSMutableSet.methods.removeAllObjects]
unsafe = false
mutating = true
[class.NSMutableSet.methods.addObject]
mutating = true

# Mutable classes
#
# Some of these are commented out because they're set above
# [class.NSMutableArray]
# owned = true
[class.NSMutableCharacterSet]
owned = true
# [class.NSMutableData]
# owned = true
# [class.NSMutableDictionary]
# owned = true
# [class.NSMutableSet]
# owned = true
[class.NSMutableOrderedSet]
owned = true
[class.NSMutableIndexSet]
owned = true
# [class.NSMutableString]
# owned = true
# [class.NSMutableAttributedString]
# owned = true
[class.NSMutableURLRequest]
owned = true
